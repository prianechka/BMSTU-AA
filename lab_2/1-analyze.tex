\chapter{Аналитическая часть}
В этом разделе будут произведена формализация задачи, а также 
рассмотрены существующие алгоритмы умножения матриц и модель для
оценки трудоёмкости алгоритмов.

\section{Формализация задачи}
Матрица - математический объект, записываемый в виде прямоугольной таблицы, который представляет
собой совокупность строк и столбцов, на пересечениях которых находятся элементы. Количество строк
и столбцов задаёт размер матрицы.

Над матрицами определены несколько основных операций, в том числе умножение. Матрицы $A$ и $B$ 
могут быть перемножены, если число столбцов матрицы $A$ равняется числу строк $B$.

Пусть матрица $A$ имеет размеры $L \times M$, а матрица $B$ -- $M \times N$. Тогда результирующая матрица
$C$ имеет размеры $L\times N$, а каждый элемент матрицы можно подсчитать по формуле \ref{first}:
\begin{equation}
	\label{first}
	C_{i, j} = \sum\limits_{r=1}^M a_{ir} * b_{rj}   (i\in[1, L]; j\in[1, N])
\end{equation}

\section{Классический алгоритм умножения матриц}
Классический алгоритм реализует формулу умножения матриц в прямом виде. Для каждого элемента
подсчитывается значение независимо от других вычислений. Преимущество этого алгоритма состоит 
в простоте реализации, а также в отсутствии дополнительных затрат на память. Но недостаток заключается
в том, что в алгоритме присутствует три полных цикла, и затраты по времени составляют $O(n^3)$. 
Реализация становится слишком затратной, поэтому были созданы другие алгоритмы умножения матриц.

\section{Алгоритм Винограда}
Подход алгоритма Винограда является иллюстрацией общей методологии, начатой в 1979 годах на основе билинейных и трилинейных форм, 
благодаря которым было получено большинство усовершенствований для умножения матриц \cite{vino}.

Рассмотрим два вектора $V = (v1, v2, v3, v4)$ и $W = (w1, w2, w3, w4)$.  

Их скалярное произведение равно (\ref{formula}) 

\begin{equation} \label{formula}
	V \cdot W=v_1 \cdot w_1 + v_2 \cdot w_2 + v_3 \cdot w_3 + v_4 \cdot w_4
\end{equation}

Равенство (\ref{formula}) можно переписать в виде (\ref{formula2}) 
\begin{equation} \label{formula2}
	V \cdot W=(v_1 + w_2) \cdot (v_2 + w_1) + (v_3 + w_4) \cdot (v_4 + w_3) - v_1 \cdot v_2 - v_3 \cdot v_4 - w_1 \cdot w_2 - w_3 \cdot w_4
\end{equation}

Действий вычисления одного значения стало больше, но выражение в правой части последнего равенства допускает предварительную обработку:
его части можно вычислить заранее и запомнить для каждой строки первой матрицы и для каждого столбца второй.

Это означает, что над предварительно обработанными элементами нам придется выполнять лишь первые два умножения и последующие пять сложений, а также дополнительно два сложения. В сравнении с классическим алгоритмом, где для вычисления скаляров требовалось четыре умножения и четыре сложения, получается выигрыш как
в количестве действий, так и в быстродействии программы, так как сложение выполняется быстрее, чем умножение.

К недостатку алгоритма можно отнести дополнительные затраты на память, так как для каждой строки первой матрицы 
и для каждого столбца второй матрицы хранится значение в массиве.

\section{Оптимизированный алгоритм Винограда}
Оптимизированный алгоритм Винограда представляет собой обычный алгоритм Винограда, за исключением следующих оптимизаций:
\begin{itemize}
	\item вычисление происходит заранее;
	\item используется битовый сдвиг, вместо деления на 2;
	\item последний цикл для нечётных элементов включён в основной цикл, используя дополнительные операции в случае нечётности N.
\end{itemize}

\section{Модель для расчёта трудоёмкости алгоритмов}
Введем модель трудоемкости для оценки алгоритмов:
\begin{enumerate}
	\item Для базовых операции: +, -, *, /, =, ==, <=, >=, !=, +=, [], ++ -- трудоёмкость равна 1.
	\item Трудоёмкость условия \textit{if УСЛОВИЕ then A else B} будет подсчитана по формуле \ref{eq}:
	\begin{equation}
		\label{eq}
		F = F_{условия} +
		\begin{cases}
			F_A &\text{, если условие выполняется}\\
			F_B &\text{, иначе}
		\end{cases}
	\end{equation}.
	\item Трудоймкость цикла \textbf{for} будет подсчитана по формуле \ref{eq:1}:
	\begin{equation}
		\label{eq:1}
		F_{for} = F_{инициализации} + F_{сравнения} + 
		N(F_{тела} + F_{инициализации} + F_{сравнения})
	\end{equation}
	\item Трудоёмкость вызова функции равна 0.
\end{enumerate}

\section{Вывод}
Были произведена формализация задачи и рассмотрены основные существующие алгоритмы умножения матрицы.