\chapter{Аналитический раздел}
В этом разделе будут рассмотрены понятие словаря, три основных алгоритма поиска в словаре, 
а также будут приведены требования к ПО.

\section{Словарь}
\textbf{Словарь} \cite{dictionary} -- структура данных, который позволяет хранить пары вида “ключ-значение” -- \textit{(k, v)}. 
Словарь поддерживает три операции:
\begin{enumerate}
	\item Добавление новой пары в словарь.
	\item Поиск по ключу в словаре.
	\item Удаление по ключу в словаре.
\end{enumerate}
В паре \textit{(k, v)} -- \textit{v} это значение, которое ассоциируется с ключом \textit{v}.
При поиске возвращается значение, которое ассоциируется с данным ключом, или “не найдено”, если по данному ключу нет значений.


\section{Алгоритм полного перебора}

\textbf{Полный перебор} \cite{search-full} -- алгоритм решения, при котором поочередно перебираются все ключи словаря, пока не будет найден нужный.

Чем дальше искомый ключ от начала словаря, тем выше трудоемкость алгоритм.
Пусть для поиска потребовалось $k$ сравнений, а весь объём словаря -- $N$.
Тогда средняя трудоемкость равна:

\begin{equation}
f = k \cdot \left(1 + \frac{N}{2} - \frac{1}{N + 1}\right)
\end{equation}


\section{Бинарный поиск}

\textbf{Бинарный поиск} \cite{search-bin} -- поиск в заранее отсортированном словаре, который заключается в сравнении со средним элементом, 
и, если ключ меньше, то продолжать поиск в левой части тем же методом, иначе -- в правой части.

Алгоритм работает только на отсортированном словаре, поэтому предварительно требуется сделать сортировку ключей в правильном порядке
(например, лексикографическом).

Пусть $k$ -- количество сравнений, требуемых для поиска слова. Тогда трудоёмкость алгоритма можно представить так:
\begin{equation}
f = b + \log_2 k
\end{equation}

\section{Поиск с помощью сегментов}

\textbf{Поиск с помощью сегментов} \cite{search-segments} -- словарь разбивается на части, в каждую из которых попадают все элементы с некоторым общим признаком -- одинаковая первая буква, цифра, слово.

Обращение к сегменту равно сумме вероятностей обращения к его ключам. Пусть $P_i$ -- вероятность обращения к $i$-ому сегменту, а $p_j$ -- вероятность обращения к $j$-ому элементу $i$-ого сегмента. Тогда вероятность выбрать нужный сегмент высчитывается так 

\begin{equation}
P_i = \sum_j p_j
\end{equation}

Затем ключи в каждом сегменте сортируются, чтобы внутри каждого сегмента можно было произвести бинарный поиск с сложностью $O(\log_2 k)$, где $k$ -- количество ключей в сегменте.
То есть, сначала выбирается нужный сегмент, а затем в нем с помощью бинарного поиска ищется нужный ключ.

\section{Реализация словаря}
Для реализации была выбрана база водителей из курса "Базы Данных". 
Ключом выступает номер паспорта, а значением - ФИО водителей. 
Гарантируется то, что номер паспорта уникальный. 
Общее количество -- 20000 записей.

\section{Требования к ПО}
Ниже будет представлен список требований к разрабатываемому программному обеспечению. 

Требования к входным данным: 
\begin{itemize}
	\item на вход подаётся ключ для поиска -- номер паспорта, состоящий из 10 цифр(без пробелов);
	\item на вход подаётся алгоритм поиска в словаре.
\end{itemize}

Требования к выводу: 
\begin{itemize}
	\item программа должна вывести ФИО, соответствующее введённому номеру паспорта;
	\item если вводного ключа нет в словаре, то программа должна вывести соответствующее информационное сообщение. 
\end{itemize}

Также программа должна предоставлять возможность измерить время поиска для каждого из алгоритмов.

\section{Вывод}
Были рассмотрены понятие словаря, три основных алгоритма поиска в словаре, 
а также были приведены требования к ПО.