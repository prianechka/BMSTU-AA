\chapter{Технологический раздел}
В этом разделе будут сформированы требования к ПО, 
приведены листинги кода и результаты тестирования.
Также будет произведена оценка трудоёмкости алгоритмов.

\section{Средства реализации программного обеспечения}
В качестве языка программирования выбран Python 3.9, так как имеется опыт разработки проектов на этом языке.
Для замера процессорного времени используется функция process\_time\_ns из библиотеки time. 
В её результат не включается время, когда процессор не выполняет задачу \cite{python}. 

\section{Требования к ПО}
Ниже будет представлен список требований к разрабатываемому программному обеспечению. 

Требования к входным данным: 
\begin{itemize}
	\item массив должен состоять из целых чисел;
	\item длина массива может быть нулевой.
\end{itemize}

Требования к выводу: 
\begin{itemize}
	\item программа должна выводить массив после сортировки по возрастанию для каждого реализованного алгоритма.
\end{itemize} 

\section{Листинг кода}
На листингах 1-3 приведены реализации различных алгоритмов сортировки по возрастанию.
\begin{lstinputlisting}[language=Python, caption=Реализация алгоритма сортировки пузырьком, linerange={2-9}, 
	basicstyle=\small\sffamily, frame=single]{src/sort.py}
\end{lstinputlisting}

\begin{lstinputlisting}[language=Python, caption=Реализация алгоритма сортировки выбором, linerange={12-20}, 
	basicstyle=\small\sffamily, frame=single]{src/sort.py}
\end{lstinputlisting}

\begin{lstinputlisting}[language=Python, caption=Реализация алгоритма сортировки выбором, linerange={23-33}, 
	basicstyle=\small\sffamily, frame=single]{src/sort.py}
\end{lstinputlisting}

\clearpage

\section{Функциональные тесты}
В таблице 3.1 приведены результаты функциональных тестов. 
В первом столбце -- исходный массив.
Во втором столбце -- правильный результат сортировки по возрастанию.
В столбцах 3-5 -- результаты сортировки реализаций алгоритмов.

\begin{table}[h]
	\caption{Результаты функциональных тестов}
	\centering
	\begin{tabular}{ | l | l | l | l | l | }
		\hline
		Массив & Ожид.Результат  & BubbleSort & SelectSort & InsertSort \\ \hline
		1 5 3 0 2 -2 6 & -2 0 1 2 3 5 6 & -2 0 1 2 3 5 6 & -2 0 1 2 3 5 6 & -2 0 1 2 3 5 6 \\
		-1 0 1 2 3 4 & -1 0 1 2 3 4 & -1 0 1 2 3 4 & -1 0 1 2 3 4 & -1 0 1 2 3 4 \\
		3 2 1 0 -1 -2 & -2 -1 0 1 2 3 & -2 -1 0 1 2 3 & -2 -1 0 1 2 3 & -2 -1 0 1 2 3\\
		* & * & * & *  & * \\
		1 & 1 & 1 & 1 & 1 \\
		1 1 1 1 1 & 1 1 1 1 1 & 1 1 1 1 1 & 1 1 1 1 1 & 1 1 1 1 1 \\
		1 -1 1 -1 & -1 -1 1 1 & -1 -1 1 1 & -1 -1 1 1 & -1 -1 1 1\\
		\hline
	\end{tabular}
\end{table}

* -- пустой массив.

Все тесты пройдены успешно.

\section{Оценка трудоёмкости}
Введем модель трудоемкости для оценки алгоритмов:
\begin{enumerate}
	\item Для базовых операции: +, -, *, /, =, ==, <=, >=, !=, +=, [], ++ -- трудоёмкость равна 1.
	\item Трудоёмкость условия \textit{if УСЛОВИЕ then A else B} будет подсчитана по формуле \ref{eq}:
		\begin{equation}
			\label{eq}
			F = F_{условия} +
			\begin{cases}
				F_A &\text{, если условие выполняется}\\
				F_B &\text{, иначе}
			\end{cases}
		\end{equation}.
	\item Трудоймкость цикла \textbf{for} будет подсчитана по формуле \ref{eq:1}:
		\begin{equation}
			\label{eq:1}
			F_{for} = F_{инициализации} + F_{сравнения} + 
				N(F_{тела} + F_{инициализации} + F_{сравнения})
		\end{equation}
	\item Трудоёмкость вызова функции равна 0.
\end{enumerate}

\subsection{Вычисление трудоёмкости сортировки пузырьком}
\textbf{Лучший случай:} Массив отсортирован; не произошло ни одного обмена за 1 проход: \newline
Трудоемкость:  $ 1 + (N-1) + (N-1)*((N-2)*(1+4)) = N + (N - 1)*(5*N - 10) = 5*N^2 - 4*N + 10 = O(n^2)$


\textbf{Худший случай:}  Массив отсортирован в обратном порядке; в каждом случае происходил обмен:\newline
Трудоемкость: $ 1 + (N-1) + (N-1)*((N-2)*(1+4 +5)) = N + (N - 1)*(10*N - 20) = 10*N^2 - 9*N + 20 = O(n^2)$

\subsection{Вычисление трудоёмкости сортировки вставками}
\textbf{Лучший случай:} Массив отсортирован; внутренние циклы состоят из одной итерации: \newline
Трудоемкость:  $1 + (N-1) * (13) = 13*N - 12 = O(n)$


\textbf{Худший случай:}  Массив отсортирован в обратном порядке; во всех внутренних циклах будет j итераций:\newline
Трудоемкость: $1 + (N-1) * (N - 1) / 2 * (13) = 6.5*N^2 - 13N - 5.5 = O(n^2) $

\subsection{Вычисление трудоёмкости сортировки выбором}
\textbf{Лучший случай:} Массив отсортирован; во внутреннем цикле нет присваиваний: \newline
Трудоемкость:  $1 + (N-1)*((N-1) * 6)  = 6N^2 - 7N + 5 = O(n^2)$


\textbf{Худший случай:}  Массив отсортирован в обратном порядке; во внутреннем цикле будут присваивания на каждой итерации:\newline
Трудоемкость: $1 + (N-1)*((N-1) * 7)  = 7N^2 - 8N + 6 = O(n^2)$

\section{Вывод}
Были сформированы требования к ПО, приведены листинги коды.
Были вычислены трудоёмкости алгоритмов и проведены функциональные тесты.
Все алгоритмы справились с тестированием.